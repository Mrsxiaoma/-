# 前端知识储备

## 目录：
* [1. JS](#1)
  
    * [1.1 继承](#1.1)
    * [1.2 闭包](#1.2)
    * [1.3 跨域](#1.3)
    * [1.4 事件流](#1.4)
    * [1.5 事件处理](#1.5)
    * [1.6 事件委托](#1.6)
    * [1.7 类型转换](#1.7)
    * [1.8 原生Ajax](#1.8)
    * [1.9 数据类型](#1.9)
       * [1.9.1 基本类型](#1.9.1)
       * [1.9.2 引用类型](#1.9.2)
    * [1.10 Promise对象](#1.10)
    * [1.11 图片轮播](#1.11)
    * [1.12 内存泄露](#1.12)
    * [1.13 函数节流](#113)
    * [1.14 原型与原型链](#1.14)
    * [1.15 浏览器错误处理](#1.15)
    * [1.16 深拷贝与浅拷贝](#1.16)
    * [1.17 原生JS实现弹出框](#1.17)
    * [1.18 操作DOM实现表格的增删](#1.18)
    * [1.19 严格模式与混杂模式](#1.19)
    * [1.20 this 对象的理解](#1.20)
    * [1.21 call、apply 和 bind 的区别以及性能](#1.21)
    * [1.22 Cookie、seesionStorage、localStrorage的区别](#1.22)
    * [1.23 浏览器缓存机制](#1.23)
    * [1.24 函数柯里化](#1.24)
    * [1.25 正则表达式](#1.25)
    * [1.25 let、const、var的区别](#1.25)
    * [1.26 new 操作符具体作用](#1.26)

* [2.CSS](#2)

    * [2.1 position 属性](#2.1)
    * [2.2 flex 布局](#2.2)
    * [2.3 box-sizing 属性](#2.3)
    * [2.4 浮动的定义及清除浮动](#2.4)
    * [2.5 css3 新增属性](#2.5)
    * [2.6 css 选择器优先级，优先算法的计算](#2.6)
    * [2.7 box-sizing 属性](#2.7)
    * [2.8 dispaly:none 和 visibility的区别](#2.8)
    * [2.9 回流与重绘](#2.9)
    * [2.10 优雅降级和渐进增强](#2.10)
    * [2.11 水平垂直布局](#2.11)
    * [2.12 圣杯布局和双飞翼布局](#2.12)
    * [2.13 左边固定右边自适应](#2.13)
    * [2.14 盒子双边框的实现](#2.14)
    * [2.15 一行文字超出范围后省略](#2.15)
    * [2.16 px, em, rem](#2.16)
    * [2.17 盒模型](#2.17)
    * [2.18 BFC原理](#2.18)
    * [2.19 绘制三角形的方法](#2.19)
    * [2.20 伪类选择器的用法](#2.20)

* [3.HTMl](#3)

    * [3.1 HTML5 新增属性](#3.1)
    * [3.2 meta 标签](#3.2)
    * [3.3 src 和 href的区别](#3.3)
    * [3.4 行内元素以及块级元素的区别](#3.4)
    * [3.5 position 属性](#3.5)
    * [3.6 css 选择器优先级，优先算法如何计算？](#3.6)
    * [3.7 box-sizing 属性](#3.7)
    * [3.8 什么是浮动，如何清除浮动？](#3.8)
  
* [4.计算机网络](#4)

    * [4.1 HTTP, HTTP 2.0, HTTPS的区别与联系](#4.1)
    * [4.2 TCP 三次握手与四次挥手](#4.2)
    * [4.3 SYN 攻击](#4.3)
    * [4.4 TCP 与 UDP 的区别](#4.4)
    * [4.5 五层协议的体系结构](#4.5)
    * [4.6 DNS 域名解析](#4.6)
    * [4.7 SNMP 协议](#4.7)
    * [4.8 DHCP 协议](#4.8)
    * [4.9 ICMP 协议](#4.9)
    * [4.10 ICMP 协议](#4.10)
    * [4.11 HTTP 状态码](#4.11)

* [5.前端框架](#5)

    * [5.1 Vue.js](#5.1)
      * [5.1.1 数据绑定原理](#5.1.1)
      * [5.1.2 组件间的通信方式](#5.1.2)
      * [5.1.3 Vue 的生命周期](#5.1.3)
      * [5.1.4 Vue 的路由](#5.1.4)
    * [5.2 JQuery.js](#5.2)
    * [5.3 React.js](#5.3)
    * [5.4 BootStrap.js](#5.4)
    * [5.5 Vuex](#5.5)
    

* [6.前端性能优化](#6)
    * [6.1 页面渲染优化—— Scroll优化](#6.1)

* [7.前端安全性问题](#7)

* [8.浏览器](#8)

* [9.前端构建工具](#9)
   * [9.1. Webpack](#9.1)
   * [9.2 Glup](#9.2)
   * [9.3 Grunt](#9.3)

* [10.CSS 预处理器](#10)
   * [10.1 Stylus ](#10.1)
   * [10.2 Less](#10.2)
   * [10.3 Sass](#10.3)
 .

* [11.移动 Web 开发](#9)


* [9.面向对象程序设计](#9)

    * [9.1 设计模式](#9.1)
    * [9.2 自顶向下，自底向上](#9.2)
 
* [10.数据库](#10.1)



<h2 id="1">1. JS</h2>
JavaScript是一种动态类型（相同变量可用作不同类型）、弱类型（隐式转换）、基于原型的语言。
<h3 id="1.1">1.1 继承</h3>
（1） 什么是面向对象,有什么特性？</br>
　　面向对象是一种编程思想,将属性和行为封装到对象中，让对象实现具体细节，操作方便，简化过程（电视机：外壳对象，内部是属性和方法）。特性：1. 封装：隐藏对象的属性和实现细节，仅提供对外的访问方式（提高安全性）；2. 继承：两个类之间存在着一定的所属关系（提高代码复用性）；3. 多态：是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。<br>
（2）　创建对象
<h3 id="1.11">1.11 图片轮播</h3>

    #tab {
        overflow: hidden;
        width: 400px;
        height: 250px;
        position: relative;
        float: left;
    }
    
    /*让img第一个子元素以外的其他子元素隐藏*/
     #tab>img:not(:first-child) {
        display: none;
    }
    </style>
    <script>
    window.onload = function() {
        var images = document.getElementsByTagName('img')
        var pos = 0
        var len = images.length
        setInterval(function() {
            images[pos].style.display = 'none'
            pos = ++pos == len ? 0 : pos
            images[pos].style.display = 'inline'
        }, 1000)

    }
    </script>

     <div id="tab">
        <img src="./img/chicken.png" />
        <img src="./img/fish.png" />
        <img src="./img/fox.png" />
        <img src="./img/pangxie.png" />
    </div>


<h3 id="1.2">1.2 第二级说明2</h3>
这是二级目录的第二个测试文本。
<h2 id="2">2. CSS</h2>
<h3 id="2.1">2.1 position 的属性</h3>

|     值   | 说明 |
| -------- | --- |
| relative | 相对定位，对象遵循正常的文档流，使用 top、left、right、bottom 定位，其层叠样式通过  z-index 定义。  |
| static   | （默认）无定位，对象遵循正常的文档流， top、left、right、bottom 无效 |
| stickty  | 粘性定位，对象遵循文档流，元素在超过阈值之前为绝对定位，之后为固定定位，必须制定 top 、bottom、left、right 四个阈值其中之一，否则不会触发 BFC，z-index失效 |
| absolute | 绝对定位，对象脱离文档流，相对于最近的 position 非 static 父元素使用 top、left、right、bottom 进行定位，其层叠样式通过  z-index 定义。 |
| fixed    | 固定定位，对象脱离文档流，相对于浏览器窗口使用 top、left、right、bottom 进行定位，出现滚动条时，不会随滚动条滚动。其层叠样式通过  z-index 定义。 |
| inherit  | 规定从父元素继承 position 的值  |

<h2 id="4">4. 计算机网络</h2>
<h3 id="4.1">4.1 HTTP, HTTP 2.0, HTTPS的区别与联系</h3>    

1. HTTP 2.0 新特性 —— 改进传输性能，实现低延迟和高吞吐量
 
 特性|说明
-|-
多路复用|多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求响应消息（在 HTTP/1.1 协议中浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞
二进制分帧|在应用层 （HTTP 2.0）和传输层（TCP / UDP)之间加一个二进制分帧层（在二进制分帧层中，HTTP 2.0 将所有传输的信息分割为更小的信息和帧，并对它们采用二进制编码
首部压缩|HTTP/1.1并不支持首部压缩，为此出现了 SPDY 和 HTTP2.0，SPDY 使用的是通用的DEFLATE算法，而HTTP/2使用的是专门为首部压缩设计的HPACK算法
服务端推送|在 HTTP/1.1 协议中 「浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞

2. HTTP1.0 和 HTTP1.1 的区别

-  过期时间：HTTP 1.0 —— Expires -> (过期）Response:last - Modified ->Request : If - Modified - Since<br>
　　　　　HTTP 1.1— |Cache - Control -> (过期）Response:ETag ->Request : If - None - Match

- Host头处理: HTTP 1.1 增加了 Host 头域，指明了服务器域名以及端口号，如果请求消息头中没有 host，则报 400 错误
- 长连接：HTTP 1.1 支持长连接，Connection:keep-alive，弥补了 HTTP 1.0 每次请求都要创建连接的特点
- 错误通知处理：HTTP 1.1 增加了 24 个错误状态码，如 409 请求的资源与当前资源的状态发生冲突；410服务器上的某个资源被永久性删除
- 带宽优化以及网络连接的使用：HTTP 1.0 存在带宽浪费，例如客户端只需要某个对象的一部分，而服务器却将整个对象传输过来，并不支持断点功能。HTTP 1.1 中有range头域，它允许只请求资源的一部分，即返回码是 206（Part Content），方便开发者充分利用带宽（单位时间内能传输的数据量）。

3. HTTP 和 HTTPS 

       HTTPS：是以安全为目的的 HTTP 通道，即HTTP下加入SSL层，HTTPS的安全基础是SSL（安全套接层）
       作用：1. 建立一个信息安全通道，保证数据传输的安全；2.确认网站的真实性

- HTTP 和 HTTPS 的 URL 不同，默认端口号不同，前者是 80 ，后者是 433
- HTTP 无需加密，HTTPS对传输数据进行加密
- HTTP 无需证书，HTTPS要有认证书
- 在 OSI 模型中，HTTP 位于应用层，HTTPS 在传输层

<h2 id="6">6.前端性能优化</h2>
<h3 id="6.1">6.1 页面渲染优化—— Scroll优化</h3>

- <mark>滚动优化产生的原因：</mark>
    当 scroll 、resize 事件在很短的时间内被多次触发时，会涉及到大量元素位置的计算,DOM 操作、元素重绘。当前这些工作在下一个事件触发前没有做完时，就会造成浏览器的卡顿，持续触发scorll导致掉帧扩大，浏览器 CPU 使用率增加，影响用户体验。

-  <mark>高频触发事件：</mark>
      1. window对象的resize、scroll事件

      2. 拖拽时的mousemove事件

      3. 射击游戏中的mousedown、keydown事件

      4. 文字输入、自动完成的keyup事件

-  <mark>应用场景：</mark> 

      1. 图片懒加载 

      2. 下滑自动加载数据 

      3. 侧边浮动导航栏
-  <mark>解决方法：</mark> 函数去抖和函数节流

      1. 函数去抖：调用动作 XXX 毫秒后，才会执行该动作，若在这 XXX 毫秒内又调用此动作则将重新计算执行时间。

      2.  函数节流：只允许一个函数在 XXX  毫秒内执行一次，只有当上一次函数执行后过了你规定的时间间隔，才能进行下一次该函数的调用。

      3.  pointer-events: none （禁止鼠标行为）可用来提高滚动时的帧频。的确，当滚动时，鼠标悬停在某些元素上，则触发其上的 hover 效果，然而这些
            影响通常不被用户注意，并多半导致滚动出现问题。对 body 元素应用 pointer-events: none ，禁用了包括 hover 在内的鼠标事件，从而提高滚动性能。

