# 前端知识储备

## 目录：
* [1. JS](#1)
  
    * [1.1 继承](#1.1)
    * [1.2 闭包](#1.2)
    * [1.3 跨域](#1.3)
    * [1.4 事件流](#1.4)
    * [1.5 事件处理](#1.5)
    * [1.6 事件委托](#1.6)
    * [1.7 类型转换](#1.7)
    * [1.8 原生Ajax](#1.8)
    * [1.9 数据类型](#1.9)
       * [1.9.1 基本类型](#1.9.1)
       * [1.9.2 引用类型](#1.9.2)
    * [1.10 Promise对象](#1.10)
    * [1.11 图片轮播](#1.11)
    * [1.12 内存泄露](#1.12)
    * [1.13 函数节流](#113)
    * [1.14 原型与原型链](#1.14)
    * [1.15 浏览器错误处理](#1.15)
    * [1.16 深拷贝与浅拷贝](#1.16)
    * [1.17 原生JS实现弹出框](#1.17)
    * [1.18 操作DOM实现表格的增删](#1.18)
    * [1.19 严格模式与混杂模式](#1.19)
    * [1.20 this 对象的理解](#1.20)
    * [1.21 call、apply 和 bind 的区别以及性能](#1.21)
    * [1.22 Cookie、seesionStorage、localStrorage的区别](#1.22)
    * [1.23 浏览器缓存机制](#1.23)
    * [1.24 函数柯里化](#1.24)
    * [1.25 正则表达式](#1.25)
    * [1.25 let、const、var的区别](#1.25)
    * [1.26 new 操作符具体作用](#1.26)
    * [1.27 setTimeout 和 setInterval](#1.27)

* [2.CSS](#2)

    * [2.1 position 属性](#2.1)
    * [2.2 flex 布局](#2.2)
    * [2.3 box-sizing 属性](#2.3)
    * [2.4 浮动的定义及清除浮动](#2.4)
    * [2.5 css3 新增属性](#2.5)
    * [2.6 css 选择器优先级，优先算法的计算](#2.6)
    * [2.7 box-sizing 属性](#2.7)
    * [2.8 dispaly:none 和 visibility的区别](#2.8)
    * [2.9 回流与重绘](#2.9)
    * [2.10 优雅降级和渐进增强](#2.10)
    * [2.11 水平垂直布局](#2.11)
    * [2.12 圣杯布局和双飞翼布局](#2.12)
    * [2.13 左边固定右边自适应](#2.13)
    * [2.14 盒子双边框的实现](#2.14)
    * [2.15 一行文字超出范围后省略](#2.15)
    * [2.16 px, em, rem](#2.16)
    * [2.17 盒模型](#2.17)
    * [2.18 BFC原理](#2.18)
    * [2.19 绘制三角形的方法](#2.19)
    * [2.20 伪类选择器的用法](#2.20)

* [3.HTMl](#3)

    * [3.1 HTML5 新增属性](#3.1)
    * [3.2 meta 标签](#3.2)
    * [3.3 src 和 href的区别](#3.3)
    * [3.4 行内元素以及块级元素的区别](#3.4)
    * [3.5 position 属性](#3.5)
    * [3.6 css 选择器优先级，优先算法如何计算？](#3.6)
    * [3.7 box-sizing 属性](#3.7)
    * [3.8 什么是浮动，如何清除浮动？](#3.8)
  
* [4.计算机网络](#4)

    * [4.1 HTTP, HTTP 2.0, HTTPS的区别与联系](#4.1)
    * [4.2 TCP 三次握手与四次挥手](#4.2)
    * [4.3 SYN 攻击](#4.3)
    * [4.4 TCP 与 UDP 的区别](#4.4)
    * [4.5 五层协议的体系结构](#4.5)
    * [4.6 DNS 域名解析](#4.6)
    * [4.7 SNMP 协议](#4.7)
    * [4.8 DHCP 协议](#4.8)
    * [4.9 ICMP 协议](#4.9)
    * [4.10 ICMP 协议](#4.10)
    * [4.11 HTTP 状态码](#4.11)

* [5.前端框架](#5)

    * [5.1 Vue.js](#5.1)
      * [5.1.1 数据绑定原理](#5.1.1)
      * [5.1.2 组件间的通信方式](#5.1.2)
      * [5.1.3 Vue 的生命周期](#5.1.3)
      * [5.1.4 Vue 的路由](#5.1.4)
    * [5.2 JQuery.js](#5.2)
    * [5.3 React.js](#5.3)
    * [5.4 BootStrap.js](#5.4)
    * [5.5 Vuex](#5.5)
    

* [6.前端性能问题](#6)
    * [6.1 页面渲染优化—— Scroll优化](#6.1)
    * [6.2 高性能网站建设](#6.2)

* [7.前端安全性问题](#7)

* [8.浏览器](#8)
   * [8.1 浏览器渲染页面](#8.1)


* [9.前端构建工具](#9)
   * [9.1. Webpack](#9.1)
   * [9.2 Glup](#9.2)
   * [9.3 Grunt](#9.3)

* [10.CSS 预处理器](#10)
   * [10.1 Stylus ](#10.1)
   * [10.2 Less](#10.2)
   * [10.3 Sass](#10.3)
 .

* [11.移动 Web 开发](#9)


* [9.面向对象程序设计](#9)

    * [9.1 设计模式](#9.1)
    * [9.2 自顶向下，自底向上](#9.2)
 
* [10.数据库](#10.1)



<h2 id="1">1. JS</h2>
JavaScript是一种动态类型（相同变量可用作不同类型）、弱类型（隐式转换）、基于原型的语言。
<h3 id="1.1">1.1 继承</h3>
（1） 什么是面向对象,有什么特性？</br>
　　面向对象是一种编程思想,将属性和行为封装到对象中，让对象实现具体细节，操作方便，简化过程（电视机：外壳对象，内部是属性和方法）。特性：1. 封装：隐藏对象的属性和实现细节，仅提供对外的访问方式（提高安全性）；2. 继承：两个类之间存在着一定的所属关系（提高代码复用性）；3. 多态：是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。<br>
（2）　创建对象
- 使用 Oject 构造函数和对象字面量,缺点：使用同一个接口创建很多对象，会产生大量重复代码
- 工厂模式：使用函数特定的接口封装对象的细节  
<h3 id="1.11">1.11 图片轮播</h3>

    #tab {
        overflow: hidden;
        width: 400px;
        height: 250px;
        position: relative;
        float: left;
    }
    
    /*让img第一个子元素以外的其他子元素隐藏*/
     #tab>img:not(:first-child) {
        display: none;
    }
    </style>
    <script>
    window.onload = function() {
        var images = document.getElementsByTagName('img')
        var pos = 0
        var len = images.length
        setInterval(function() {
            images[pos].style.display = 'none'
            pos = ++pos == len ? 0 : pos
            images[pos].style.display = 'inline'
        }, 1000)

    }
    </script>

     <div id="tab">
        <img src="./img/chicken.png" />
        <img src="./img/fish.png" />
        <img src="./img/fox.png" />
        <img src="./img/pangxie.png" />
    </div>

<h3 id = "1.21">1.21 call、apply 和 bind 的区别以及性能</h3>

> apply、call 和 bind 都可以改变当前函数 this 的指向。但是 apply 传的参数时一个数组，call 传的参数是一个序列。bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。

- apply的使用　　

    1. 基本使用，apply 将 Function 中的 this 指向了 newObj 这个对象，args 参数是传给 newObj 中的 Function 的参数，call 类似。
      	```
	    Function.prototype.apply(newObj,［arg1，arg2，arg3])  
      	```
   2. 求一个数组的最大值，在非严格模式下，此时的 null（undefined）是JS执行环境的全局变量window，因为 Math.max( ) 不支持数组，所以此时用 apply 函数时，传入Math.max( ) 中的参数为数组中的值，而不是整个数组。
 
		```
		Math.max.apply(null,［1，2，3])   	
        ```
   3. 数组合并
      ```
       Array.prototype.push.apply(array1, array2)
      ```

- call 的使用

	 1. 基本使用
  
	    ```
	     Function.prototype.apply(newObj, arg1，arg2，arg3)  
	    ```
	 2.  类数组的用法，将类数组变为数组
  
	      ```
	      Array.prototype.slice.call(arguments)
	      Array.prototype.slice.call(document.getElementsByTagName("*"))
	     ```
- bind 的使用
	 1. 基本使用
  
	    ```
	      Function.prototype.bind(newObj)  
	    ```
- 补充
    call 的性能比 apply 好，因为 apply 的参数是一个数组，会多一次引用访问，而且需要将其遍历合并到arguments隐式参数数组上。

 
<h3 id="1.25">1.25 let、const、var的区别</h3>

- let :<b>暂时性死区</b>，使用 let 声明之前，该变量都不可用，本质是，只要一进入当前作用域，要使用的变量已经存在，但是不可获取，只有等声明变量代码出现，才可以获取和使用该变量
- var :<b>变量提升 </b>，变量在未声明之前使用，值为 undifined
- const :<b>赋值报错</b>，使用 const 声明一个只读变量，不可修改，而且必须初始化

<h3 id="1.27">1.27 setTimeout 和 setInterval</h3>

- setTimeout

          setTimeout 在指定的毫秒数后，将定时任务处理的函数添加到执行队列的队尾，它是异步的，有两个参数，第一个参数是函数，第二参数是时间值。 调用 setTimeout 时，把第一个参数，放到事件队列中。等主程序运行完，再调用。

- setInterval 

          setInterval 是每隔 XXX 毫秒，执行一次函数，它也是异步的


<h2 id="2">2. CSS</h2>
<h3 id="2.1">2.1 position 的属性</h3>

|     值   | 说明 |
| -------- | --- |
| relative | 相对定位，对象遵循正常的文档流，使用 top、left、right、bottom 定位，其层叠样式通过  z-index 定义。  |
| static   | （默认）无定位，对象遵循正常的文档流， top、left、right、bottom 无效 |
| stickty  | 粘性定位，对象遵循文档流，元素在超过阈值之前为绝对定位，之后为固定定位，必须制定 top 、bottom、left、right 四个阈值其中之一，否则不会触发 BFC，z-index失效 |
| absolute | 绝对定位，对象脱离文档流，相对于最近的 position 非 static 父元素使用 top、left、right、bottom 进行定位，其层叠样式通过  z-index 定义。 |
| fixed    | 固定定位，对象脱离文档流，相对于浏览器窗口使用 top、left、right、bottom 进行定位，出现滚动条时，不会随滚动条滚动。其层叠样式通过  z-index 定义。 |
| inherit  | 规定从父元素继承 position 的值  |

<h2 id="4">4. 计算机网络</h2>
<h3 id="4.1">4.1 HTTP, HTTP 2.0, HTTPS的区别与联系</h3>    

1. HTTP 2.0 新特性 —— 改进传输性能，实现低延迟和高吞吐量
 
 特性|说明
-|-
多路复用|多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求响应消息（在 HTTP/1.1 协议中浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞
二进制分帧|在应用层 （HTTP 2.0）和传输层（TCP / UDP)之间加一个二进制分帧层（在二进制分帧层中，HTTP 2.0 将所有传输的信息分割为更小的信息和帧，并对它们采用二进制编码
首部压缩|HTTP/1.1并不支持首部压缩，为此出现了 SPDY 和 HTTP2.0，SPDY 使用的是通用的DEFLATE算法，而HTTP/2使用的是专门为首部压缩设计的HPACK算法
服务端推送|在 HTTP/1.1 协议中 「浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞

2. HTTP1.0 和 HTTP1.1 的区别

-  过期时间：HTTP 1.0 —— Expires -> (过期）Response:last - Modified ->Request : If - Modified - Since<br>
　　　　　HTTP 1.1— |Cache - Control -> (过期）Response:ETag ->Request : If - None - Match

- Host头处理: HTTP 1.1 增加了 Host 头域，指明了服务器域名以及端口号，如果请求消息头中没有 host，则报 400 错误
- 长连接：HTTP 1.1 支持长连接，Connection:keep-alive，弥补了 HTTP 1.0 每次请求都要创建连接的特点
- 错误通知处理：HTTP 1.1 增加了 24 个错误状态码，如 409 请求的资源与当前资源的状态发生冲突；410服务器上的某个资源被永久性删除
- 带宽优化以及网络连接的使用：HTTP 1.0 存在带宽浪费，例如客户端只需要某个对象的一部分，而服务器却将整个对象传输过来，并不支持断点功能。HTTP 1.1 中有range头域，它允许只请求资源的一部分，即返回码是 206（Part Content），方便开发者充分利用带宽（单位时间内能传输的数据量）。

3. HTTP 和 HTTPS 

       HTTPS：是以安全为目的的 HTTP 通道，即HTTP下加入SSL层，HTTPS的安全基础是SSL（安全套接层）
       作用：1. 建立一个信息安全通道，保证数据传输的安全；2.确认网站的真实性

- HTTP 和 HTTPS 的 URL 不同，默认端口号不同，前者是 80 ，后者是 433
- HTTP 无需加密，HTTPS对传输数据进行加密
- HTTP 无需证书，HTTPS要有认证书
- 在 OSI 模型中，HTTP 位于应用层，HTTPS 在传输层

<h2 id="6">6.前端性能优化</h2>
<h3 id="6.1">6.1 页面渲染优化—— Scroll优化</h3>

- <mark>滚动优化产生的原因：</mark>
    当 scroll 、resize 事件在很短的时间内被多次触发时，会涉及到大量元素位置的计算,DOM 操作、元素重绘。当前这些工作在下一个事件触发前没有做完时，就会造成浏览器的卡顿，持续触发scorll导致掉帧扩大，浏览器 CPU 使用率增加，影响用户体验。

-  <mark>高频触发事件：</mark>
      1. window对象的resize、scroll事件

      2. 拖拽时的mousemove事件

      3. 射击游戏中的mousedown、keydown事件

      4. 文字输入、自动完成的keyup事件

-  <mark>应用场景：</mark> 

      1. 图片懒加载 

      2. 下滑自动加载数据 

      3. 侧边浮动导航栏
-  <mark>解决方法：</mark> 函数去抖和函数节流

      1. 函数去抖：调用动作 XXX 毫秒后，才会执行该动作，若在这 XXX 毫秒内又调用此动作则将重新计算执行时间。

      2.  函数节流：只允许一个函数在 XXX  毫秒内执行一次，只有当上一次函数执行后过了你规定的时间间隔，才能进行下一次该函数的调用。

      3.  pointer-events: none （禁止鼠标行为）可用来提高滚动时的帧频。的确，当滚动时，鼠标悬停在某些元素上，则触发其上的 hover 效果，然而这些
            影响通常不被用户注意，并多半导致滚动出现问题。对 body 元素应用 pointer-events: none ，禁用了包括 hover 在内的鼠标事件，从而提高滚动性能。

<h3 id="6.2">6.2 高性能网站建设</h3>

<h4>一、减少 http 请求</h4>

原理：因为只有 10% ~ 20% 的最终用户响应时间花在接受所请求的 HTML 文档上，剩下的 80% ~ 90% 的时间花在为HTM所引用的组件（图片、脚本，样式表等)进行的HTTP请求上，所以减少组件的数量，减少HTTP请求，就可以减少响应时间

方法：
- 图片地图：允许在一个图片上关联多个 url。目标 url 的选择取决于用户点击图片的哪个位置
- CSS Sprites 雪碧图
- 内联图片：IE 不支持，数据大小有限制，eg: ```<img src="data:imgage/gif...."/>```
- 划分主域
- 拆分初始化负载：将页面加载的 js 文件分为：渲染界面必须的和其他的，初始化之家在必须的

<h4>二、使用内容分发网络 CDN</h4>

原理：CDN 是一组分布在多个不同地理位置的 Web 服务器，用于更加有效地向用户发布内容。如果 Web 服务器离用户够近，就可以大幅度减少响应时间。

<h4>三、添加 Expires 头/ Cache-Control = max-age （http1.1）</h4>

原理： 缓存组件，避免不必要的http请求


<h4>四、压缩组件</h4>

原理： 通过减少 http 响应的大小来减少响应时间，如果 http 请求产生的响应包很小，传输时间就会减少（提高请求带宽（传输速率））

- 开启 Gzip （压缩 html,js,css文件）
- 精简 JS，图像优化

<h4>五、将样式表放在首部</h4>

原理 ：避免白屏，使页面逐步呈现，提高用户体验


<h4>六、将脚本放在底部</h4>

原理 ：使页面逐步呈现，提高下载的并行速度

<h4>七、避免 CSS 表达式</h4>
<h2 id="8">8. 浏览器</h2>
<h3 id="8.1">8.1 浏览器渲染页面</h3>

1. 浏览器解析html源码，然后创建一个 DOM树。
在DOM树中，每一个HTML标签都有一个对应的节点，并且每一个文本也都会有一个对应的文本节点。DOM树的根节点就是 documentElement，对应的是html标签。

2. 浏览器解析CSS代码，计算出最终的样式数据。
对CSS代码中非法的语法她会直接忽略掉。解析CSS的时候会按照如下顺序来定义优先级：浏览器默认设置 < 用户设置 < 外链样式 < 内联样式 < html中的style。

3. 构建出DOM树，并且计算出样式数据后，下一步就是构建一个 渲染树（rendering tree）。渲染树和DOM树有点像，但是是有区别的。DOM树完全和html标签一一对应，但是渲染树会忽略掉不需要渲染的元素，比如head、display:none的元素等。而且一大段文本中的每一个行在渲染树中都是独立的一个节点。渲染树中的每一个节点都存储有对应的css属性。

4. 一旦渲染树创建好了，浏览器就可以根据渲染树直接把页面绘制到屏幕上。

链接：http://www.jianshu.com/p/f59bc859d771
